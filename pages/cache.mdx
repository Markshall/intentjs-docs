---
title: Cache
description:
image:
---

import Image from "next/image";
import { Cards, Card } from "nextra/components";
import {
  RedisLogo,
  InMemoryCacheLogo,
} from "../src/components/images/providers";
import { Callout } from "nextra/components";

# Cache

In some cases, applications may perform resource-intensive operations, such as complex computations or retrieving large amounts of data. These tasks can be time-consuming and put a strain on the CPU. Additionally, if the data doesn't change frequently, it's often beneficial to store it in a cache. This approach allows the application to quickly access the information from the cache instead of making repeated network calls, which can improve performance and reduce system load.

In those cases, you may want to save it in a fast-read store so that you don't need to run the computation again and again. When the data is cached, it can be retrieved quickly on subsequent requests for the same data.

Intent provides a multi-store cache provider for your applications. We support the following caches.
This package provides a multi-store cache provider for your Intent application. Currently supports the following caches.

<Cards>
  <Card icon={<RedisLogo />} title="Redis" href="" />
  <Card
    icon={<InMemoryCacheLogo />}
    title="Tabs"
    href="/docs/guide/built-ins/tabs"
  />
</Cards>

## Configuration

Cache configuration is defined in `config/cache.ts` file. By default, Intent comes with a pre-configured with `local` cache, to use it you don't need to do anything.

### Local Cache

Local cache is a zero-dependency store that you can use without starting any extra server.

```ts
import { registerAs } from "@nestjs/config";
import { CacheOptions } from "@intentjs/core";

export default registerAs(
  "cache",
  () =>
    ({
      default: "local",
      stores: {
        local: {
          driver: "local",
          prefix: "intentjs",
        },
      },
    } as CacheOptions)
);
```

### Redis Cache

For production related workloads, we recommend using an external cache store like `Redis`. To configure Redis, you can configure your store like below.

If you would like to configure different cache stores, you can do so like below in `config/cache.ts` file:

```typescript
import { registerAs } from "@nestjs/config";
import { CacheOptions } from "@intentjs/core";

export default registerAs(
  "cache",
  () =>
    ({
      default: "redis",
      stores: {
        redis: {
          driver: "redis",
          host: process.env.REDIS_HOST || "127.0.0.1",
          username: process.env.REDIS_USERNAME || undefined,
          password: process.env.REDIS_PASSWORD || undefined,
          port: process.env.REDIS_PORT || 6379,
          database: process.env.REDIS_DB || 0,
          prefix: "intentjs",
        },
      },
    } as CacheOptions)
);
```

## Usage

Intent ships two `Cache` and `CacheStore` utilities to start interacting with the stores. Both are importable from '@intentjs/core'.

```typescript
// method
import { CacheStore } from "@intentjs/core";
const store = CacheStore();
// returns the default store

// class
import { Cache } from "@intentjs/core";
const store = Cache.store();
// returns the default store
```

If you would like to access a store other than the `default` store, you can pass the name of the store as an arg.

```ts
import { CacheStore } from "@intentjs/core";
const store = CacheStore("redis");
// returns the "redis" store

// class
import { Cache } from "@intentjs/core";
const store = Cache.store("local");
// returns the "local" store
```

### Writing to Cache

To write data to a cache, you can use the `set` method.

```ts
await Cache.store().set("otp", 1234);
// returns true if successfully written

await Cache.store().set("book_name", "Shoe Dog")
// returns true if successfully written
```

Apart from `number` and `strings`, you can also store `objects` or `arrays` in the cache store. It internally converts them to `string` and returns back as POJO objects when you try to get it.

```ts
const books = [
  {
    name: 'Shoe Dog',
    author: 'Phil Knight',
  },
  {
    name: 'The Silva Mind Control Method',
    author: 'Jos√© Silva',
  },
];

await Cache.store().set('books', books);
```

### Reading Cache

To read data from a store, you can make use of the `get` method.

<Callout type="info">
If you pass a class instance to the `get` method, it is converted to Plain Old Javascript Object (POJO), and stored as a string. When you 
</Callout>

```typescript
await CacheStore().get("reset_password_token");
// will return 'abcd123456'
```


```typescript
// saved forever in the store
await CacheStore().set("reset_password_token", "abcd123456");

// saved for 2 mins or 120 seconds in the store
await CacheStore().set("reset_password_token", "abcdef12345678", 120);
```


To check if key exists in the store, you can use `.has()` method

```typescript
await CacheStore().has("reset_password_token");
// will return `true` if found, else `false`
```

To remove a key from the store, use `.forget()` method

```typescript
await CacheStore().forget("reset_password_token");
```

In a much more real world use case, you may want to process something and then save it to the store, and then read from there on.

In such case, you can consider using `remember` and `rememberForever` methods which takes a callback, keep it's output in the store, and then automatically return the data next time onwards.

```ts
const cb = () => {
  // your custom logic here, for eg. a db query, an api call.
  return "some_random_generated_token";
};

await CacheStore().remember("reset_password_token", cb, 120);
```

Notice the 2nd arg `cb` callback, and the 3rd arg `ttl` timeout, passed to the `remember` method. The `cb` will be processed and the value returned by the callback will be serialized and saved to the store automatically for `ttl` time.

If you want to just store the data without any expiry, you can use the `rememberForever` method.

```ts
const cb = () => {
  // your custom logic here, for eg. a db query, an api call.
  return "some_random_generated_token";
};

await CacheStore().rememberForever("reset_password_token", cb);
```

The above example saves the data indefinitely in the redis store. The only difference between the `rememberForever` and `remember` method is the expiry time (3rd argument) of the key in the store.

## Extras

There might be instances where you would want to generate unique keys with multiple values, and to maintain a uniformity and consistency, Intent also comes with a `genKey` method.

```typescript
const key = Cache.genKey({ type: "reset_password_token", userId: 1234 });
console.log(key); // type[reset_password_token],userId[1234]
```

`genKey` method automatically sorts the object's key in lexical order and return a string which later can be used as a key.
